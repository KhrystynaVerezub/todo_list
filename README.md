# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown. 


тут моэно найти полную инструкцию на гите:
https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c



## HEAD в хешах
HEAD - служебный файл и служит как указатель последнего коммита. 
Если ввести HEAD - покажет последний коммит.
Хеш - индивидуальный номер коммита


## GIT LOG
Через команду git log --oneline  - можно получить список сокращенных хешей коммита.
Через него мы можем искать коммит или прыгать по веткам


## GIT STATUS
Схему изменения статусов можно описать словами. Например, modified+git add = staged.

HEAD -- это голова.
Коммит -- это всему голова.
Статусы файлов:
<тут пустая строка!>

```mermaid
%% описание схемы
```
<и тут пустая строка!>


## Как исправить коммит
внести правки в уже сделанный коммит с помощью опции --amend

Дополнить коммит новыми файлами — git commit --amend --no-edit.

С опцией --amend команда commit не создаст новый коммит, а дополнит последний, просто добавив в него файл common.css. При этом хеш последнего коммита изменится, потому что изменился список файлов в коммите.
Обратите внимание на опцию --no-edit. Она сообщает команде commit, что сообщение коммита нужно оставить как было.

--amend рассчитан на работу с последним коммитом (HEAD).

Дополнить коммит новыми файлами можно с помощью git commit --amend --no-edit. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.

Изменить сообщение к коммиту позволяет команда git commit --amend -m "Обновлённое сообщение коммита".


##Как откатиться назад, если «всё сломалось»
Выполнить unstage изменений — git restore --staged <file>
«Откатить» коммит — git reset --hard <commit hash>
«Откатить» изменения, которые не попали ни в staging, ни в коммит, — git restore <file>




Команда git restore --staged <file> переведёт файл из staged обратно в modified или untracked.
Команда git reset --hard <commit hash> «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
Команда git restore <file> «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.


###Шпаргалка. Работа с ветками
В этой шпаргалке мы собрали все ключевые команды модуля — они наверняка пригодятся вам в реальной работе с ветками!
Клонирование чужого репозитория
git clone git@github.com:YandexPraktikum/first-project.git (от англ. clone, «клон», «копия») — склонируй репозиторий с URL first-project.git из аккаунта YandexPraktikum на мой локальный компьютер.
Создание веток
git branch feature/the-finest-branch (от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch;
git checkout -b feature/the-finest-branch — создай ветку feature/the-finest-branch и сразу переключись на неё.
Навигация по веткам
git branch (от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
git branch -a — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в origin, или на GitHub).
git checkout feature/br — переключись на ветку feature/br.
Сравнение веток
git diff main HEAD (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD;
git diff HEAD~2 HEAD — покажи разницу между тем коммитом, который был два коммита назад, и текущим.
Удаление веток
git branch -d br-name — удали ветку br-name, но только если она является частью main;
git branch -D br-name — удали ветку br-name, даже если она не объединена с main.
Слияние веток
git merge main (от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой. 
Работа с удалённым репозиторием
git push -u origin my-branch (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u;
git push my-branch — отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;
git pull (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.