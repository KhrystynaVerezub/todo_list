# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown. 


тут моэно найти полную инструкцию на гите:
https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c



## HEAD в хешах
HEAD - служебный файл и служит как указатель последнего коммита. 
Если ввести HEAD - покажет последний коммит.
Хеш - индивидуальный номер коммита


## GIT LOG
Через команду git log --oneline  - можно получить список сокращенных хешей коммита.
Через него мы можем искать коммит или прыгать по веткам


## GIT STATUS
Схему изменения статусов можно описать словами. Например, modified+git add = staged.

HEAD -- это голова.
Коммит -- это всему голова.
Статусы файлов:
<тут пустая строка!>

```mermaid
%% описание схемы
```
<и тут пустая строка!>


## Как исправить коммит
внести правки в уже сделанный коммит с помощью опции --amend

Дополнить коммит новыми файлами — git commit --amend --no-edit.

С опцией --amend команда commit не создаст новый коммит, а дополнит последний, просто добавив в него файл common.css. При этом хеш последнего коммита изменится, потому что изменился список файлов в коммите.
Обратите внимание на опцию --no-edit. Она сообщает команде commit, что сообщение коммита нужно оставить как было.

--amend рассчитан на работу с последним коммитом (HEAD).

Дополнить коммит новыми файлами можно с помощью git commit --amend --no-edit. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.

Изменить сообщение к коммиту позволяет команда git commit --amend -m "Обновлённое сообщение коммита".


##Как откатиться назад, если «всё сломалось»
Выполнить unstage изменений — git restore --staged <file>
«Откатить» коммит — git reset --hard <commit hash>
«Откатить» изменения, которые не попали ни в staging, ни в коммит, — git restore <file>




Команда git restore --staged <file> переведёт файл из staged обратно в modified или untracked.
Команда git reset --hard <commit hash> «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
Команда git restore <file> «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.